<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:msxsl="urn:schemas-microsoft-com:xslt"
  version="1.0">

  <xsl:output method="xml" omit-xml-declaration="yes" />

  <!-- Common functions -->
  <xsl:include href="common.xslt" />

  <!-- Table spec file - default to _tables.xml in current directory -->
  <xsl:param name="tableSpecFile" select="'_database.xml'" />
  
  <!-- XML table data - input -->

  <!-- Reference the table specification (table.xml) -->
  <xsl:variable name="tableSpec" select="document($tableSpecFile)//tables" />

  <!-- SQL value delimiters -->
  <xsl:variable name="delimiter">
    <xsl:text>'</xsl:text>
  </xsl:variable>
  
  <xsl:variable name="delimiter2" select="concat($delimiter, $delimiter)" />

  <!-- Entry point -->
  <xsl:template match="/">

    <xsl:call-template name="sqlComment">
      <xsl:with-param name="commentText" select="'Autogenerated by tableins.xslt'" />
    </xsl:call-template>

    <xsl:call-template name="sqlComment">
      <xsl:with-param name="commentText" select="'Turn on QUOTED_IDENTIFIER option, NOCOUNT'" />
    </xsl:call-template>
    
    <xsl:text>SET QUOTED_IDENTIFIER ON; &#xa;</xsl:text>
    <xsl:text>SET NOCOUNT ON; &#xa;</xsl:text>
    <xsl:text>GO&#xa;&#xa;</xsl:text>

    <!-- Process each table -->
    <xsl:for-each select="tables/table">

      <!-- Capture the table name and schema -->
      <xsl:variable name="tableName" select="@name"/>
      <xsl:variable name="tableSchema" select="@schema"/>

      <!-- Capture the table spec from the spec document -->
      <xsl:variable name="thisTableSpec" select="$tableSpec/table[@name=$tableName and @schema=$tableSchema]"/>
      
      <!-- Check if we have data for this table -->
      <xsl:if test="count(*)>0">
        
        <!-- Get the full name of the table -->
        <xsl:variable name="tableFullName">
          <xsl:text>[</xsl:text>
          <xsl:value-of select="$tableSchema"/>
          <xsl:text>].[</xsl:text>
          <xsl:value-of select="$tableName"/>
          <xsl:text>]</xsl:text>
        </xsl:variable>
        
        <!-- Check for identity column -->
        <xsl:variable name="identity" select="boolean(count($thisTableSpec//*[@identity='1'])>0)"/>
        
        <!-- Render a comment -->
        <xsl:call-template name="sqlComment">
          <xsl:with-param name="commentText">
            <xsl:text>INSERT DATA FOR TABLE </xsl:text>
            <xsl:value-of select="$tableFullName"/>
          </xsl:with-param>
        </xsl:call-template>
        
        <!-- Turn identity insert on (if needed) -->
        <xsl:if test="$identity">
          <xsl:text>SET IDENTITY_INSERT </xsl:text>
          <xsl:value-of select="$tableFullName" />
          <xsl:text> ON; &#xa;GO&#xa;</xsl:text>
        </xsl:if>

        <!-- Turn off constraints -->
        <xsl:text>ALTER TABLE </xsl:text>
        <xsl:value-of select="$tableFullName" />
        <xsl:text> NOCHECK CONSTRAINT ALL;  &#xa;GO&#xa;</xsl:text>

        <!-- Get the unique element names -->
        <xsl:variable name="elementList">
          <xsl:for-each select="row/*">
            <xsl:element name="e">
              <xsl:value-of select="local-name()"/>
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="elementNodes" select="msxsl:node-set($elementList)" />
        <xsl:variable name="elements" select="$elementNodes/*[not(preceding::*) or not(preceding::*=.)]" />

        <!-- Go through each row and insert the values -->
        <xsl:for-each select="*">
          <xsl:choose>
            <xsl:when test="(position() mod 1000) = 1">
              <xsl:if test="position()!=1">
                <xsl:text>GO&#xa;</xsl:text>
              </xsl:if>
              <!-- Begin INSERT statement -->
              <xsl:text>&#xa;INSERT </xsl:text>
              <xsl:value-of select="$tableFullName" />
              
              <!-- Render the column spec -->
              <xsl:text> (</xsl:text>
              <xsl:for-each select="$elements">
                <xsl:if test="position()!=1">
                  <xsl:text>, </xsl:text>
                </xsl:if>
                <xsl:text>[</xsl:text>
                <xsl:value-of select="."/>
                <xsl:text>]</xsl:text>
              </xsl:for-each>
              <xsl:text>) VALUES &#xa; </xsl:text>
            </xsl:when>
            <xsl:otherwise>
              <!-- Next set of values -->
              <xsl:text>,</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
          
          <xsl:text>(</xsl:text>

          <!-- Capture the current row -->
          <xsl:variable name="thisRow" select="." />
          
          <!-- Process each element (column) and render its value -->
          <xsl:for-each select="$elements">
            
            <!-- Locals -->
            <xsl:variable name="columnName" select="text()" />
            <xsl:variable name="columnSpec" select="$thisTableSpec/columns/column[@name=$columnName]"/>

            <!-- For the column value, we need to check for XML type and render a copy of the content (XML) -->
            <xsl:variable name="columnValue">
              <xsl:choose>
                <xsl:when test="$columnSpec/@type='xml'">
                  <xsl:copy-of select="$thisRow/*[local-name()=$columnName]/*" />
                </xsl:when>
                <xsl:otherwise>
                  <xsl:copy-of select="$thisRow/*[local-name()=$columnName]"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>

            <xsl:if test="position()!=1">
              <xsl:text>, </xsl:text>
            </xsl:if>
            <xsl:call-template name="getColumnValue">
              <xsl:with-param name="columnValue" select="msxsl:node-set($columnValue)" />
              <xsl:with-param name="columnSpec" select="$columnSpec" />
            </xsl:call-template>
          </xsl:for-each>
          <xsl:text>)&#xa;</xsl:text>
        </xsl:for-each>

        <xsl:text>GO&#xa;</xsl:text>

        <!-- Turn on constraints -->
        <xsl:text>&#xa;ALTER TABLE </xsl:text>
        <xsl:value-of select="$tableFullName" />
        <xsl:text> CHECK CONSTRAINT ALL;  &#xa;GO&#xa;</xsl:text>

        <!-- Turn identity insert off (if needed) -->
        <xsl:if test="$identity">
          <xsl:text>&#xa;SET IDENTITY_INSERT </xsl:text>
          <xsl:value-of select="$tableFullName" />
          <xsl:text> OFF; &#xa;GO&#xa;</xsl:text>
        </xsl:if>

        <xsl:text>&#xa;</xsl:text>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <!-- Render single column value -->
  <xsl:template name="getColumnValue">
    <xsl:param name="columnValue" />
    <xsl:param name="columnSpec" />
    
    <xsl:choose>
      <xsl:when test="count($columnValue/node())=0">
        <xsl:text>NULL</xsl:text>        
      </xsl:when>
      <xsl:otherwise>

        <xsl:choose>
          <!-- Handle binary values (convert from base64 encoded string) -->
          <xsl:when test="$columnSpec/@type='varbinary'">
            <xsl:text>CAST(N'' AS XML).value('xs:base64Binary("</xsl:text>
            <!-- We assume that the column value is base64 encoded here, so render it directly -->
            <xsl:value-of select="$columnValue"/>
            <xsl:text>")', 'varbinary(MAX)')</xsl:text>
          </xsl:when>
          <xsl:when test="$columnSpec/@type='xml'">
            <xsl:text>N</xsl:text>
            <xsl:value-of select="$delimiter"/>
            <!-- Serialize the XML node -->
            <xsl:apply-templates select="$columnValue/*" mode="serialize"/>
            <xsl:value-of select="$delimiter"/>
          </xsl:when>
          <xsl:otherwise>
            <!-- Default rendering as '<value>' -->
            <xsl:if test="$columnSpec/@type='nvarchar' or $columnSpec/@type='ntext'">
              <xsl:text>N</xsl:text>  
            </xsl:if>
            <xsl:value-of select="$delimiter"/>
            <xsl:call-template name="escapeSqlValue">
              <xsl:with-param name="text" select="$columnValue" />
            </xsl:call-template>
            <xsl:value-of select="$delimiter"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Escape the element values -->
  <xsl:template match="text()" mode="serialize">
    <!-- Note that here, we need to XML escape the value -->
    <xsl:call-template name="escapeSqlValue">
      <xsl:with-param name="text" select="." />
      <xsl:with-param name="escapeXml" select="true()" />
    </xsl:call-template>
  </xsl:template>

  <!-- Escape the comment values -->
  <xsl:template match="comment()" mode="serialize">
    <xsl:comment>
      <xsl:call-template name="escapeSqlValue">
        <xsl:with-param name="text" select="." />
      </xsl:call-template>
    </xsl:comment>
  </xsl:template>

  <!-- Escape the attribute values -->
  <xsl:template match="@*" mode="serialize">
    <xsl:attribute name="{local-name()}" namespace="{namespace-uri()}">
      <xsl:call-template name="escapeSqlValue">
        <xsl:with-param name="text" select="." />
      </xsl:call-template>
    </xsl:attribute>
  </xsl:template>
  
  <!-- Entry point for XML node serialization -->
  <xsl:template match="* | processing-instruction()" mode="serialize">
    <!-- We assume that the element names do not need escaping -->
    <xsl:copy>
      <xsl:apply-templates select="node() | @*" mode="serialize" />
    </xsl:copy>
  </xsl:template>

  <!-- SQL value escaping helper -->
  <xsl:template name="escapeSqlValue">
    <xsl:param name="text" />
    <xsl:param name="escapeXml" select="false()" />
    <xsl:call-template name="replaceString">
      <xsl:with-param name="text" select="$text" />
      <xsl:with-param name="replace" select="$delimiter" />
      <xsl:with-param name="with" select="$delimiter2" />
      <xsl:with-param name="escapeXml" select="$escapeXml" />
    </xsl:call-template>
  </xsl:template>

</xsl:stylesheet>  
